// src/client/formatStats.ts
var friendlySyntaxErrorLabel = "SyntaxError:";
function isLikelyASyntaxError(message) {
  return message.includes(friendlySyntaxErrorLabel);
}
function formatMessage(stats) {
  let lines = [];
  let message;
  if (typeof stats === "object") {
    const fileName = stats.moduleName ? `File: ${stats.moduleName}
` : "";
    const mainMessage = typeof stats.formatted === "string" ? stats.formatted : stats.message;
    const details = stats.details ? `
Details: ${stats.details}
` : "";
    const stack = stats.stack ? `
${stats.stack}` : "";
    message = `${fileName}${mainMessage}${details}${stack}`;
  } else {
    message = stats;
  }
  lines = message.split("\n");
  lines = lines.map((line) => {
    const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(
      line
    );
    if (!parsingError) {
      return line;
    }
    const [, errorLine, errorColumn, errorMessage] = parsingError;
    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`;
  });
  message = lines.join("\n");
  message = message.replace(
    /SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g,
    `${friendlySyntaxErrorLabel} $3 ($1:$2)
`
  );
  lines = message.split("\n");
  if (lines.length > 2 && lines[1].trim() === "") {
    lines.splice(1, 1);
  }
  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, "$1");
  if (lines[1] && lines[1].indexOf("Module not found:") !== -1) {
    lines[1] = lines[1].replace("Error: ", "");
  }
  lines = lines.filter(
    (line, index, arr) => index === 0 || line.trim() !== "" || line.trim() !== arr[index - 1].trim()
  );
  message = lines.join("\n");
  return message.trim();
}
function formatStatsMessages(json) {
  const formattedErrors = json?.errors?.map(formatMessage);
  const formattedWarnings = json?.warnings?.map(formatMessage);
  const result = {
    errors: formattedErrors || [],
    warnings: formattedWarnings || [],
    errorTips: []
  };
  if (result.errors?.some(isLikelyASyntaxError)) {
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }
  if (result.errors.length > 1) {
    result.errors.length = 1;
  }
  return result;
}

// src/client/hmr/createSocketUrl.ts
var HMR_SOCK_PATH = "/rsbuild-hmr";
function createSocketUrl(resourceQuery) {
  const searchParams = resourceQuery.substr(1).split("&");
  const options = {};
  for (const pair of searchParams) {
    const ary = pair.split("=");
    options[ary[0]] = decodeURIComponent(ary[1]);
  }
  const currentLocation = self.location;
  return getSocketUrl(options, currentLocation);
}
function formatURL({
  port,
  protocol,
  hostname,
  pathname
}) {
  if (typeof URL !== "undefined") {
    const url = new URL("http://localhost");
    url.port = port;
    url.hostname = hostname;
    url.protocol = protocol;
    url.pathname = pathname;
    return url.toString();
  }
  const colon = protocol.indexOf(":") === -1 ? ":" : "";
  return `${protocol}${colon}//${hostname}:${port}${pathname}`;
}
function getSocketUrl(urlParts, location) {
  const { host, port, path, protocol } = urlParts;
  return formatURL({
    protocol: protocol || (location.protocol === "https:" ? "wss" : "ws"),
    hostname: host || location.hostname,
    port: port || location.port,
    pathname: path || HMR_SOCK_PATH
  });
}

// src/client/hmr/index.ts
var socketUrl = createSocketUrl(__resourceQuery);
var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;
function clearOutdatedErrors() {
  if (typeof console !== "undefined" && typeof console.clear === "function") {
    if (hasCompileErrors) {
      console.clear();
    }
  }
}
function handleSuccess() {
  clearOutdatedErrors();
  const isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;
  if (isHotUpdate) {
    tryApplyUpdates();
  }
}
function handleWarnings(warnings) {
  clearOutdatedErrors();
  const isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;
  function printWarnings() {
    const formatted = formatStatsMessages({
      warnings,
      errors: []
    });
    if (typeof console !== "undefined" && typeof console.warn === "function") {
      for (let i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn(
            "There were more warnings in other files.\nYou can find a complete log in the terminal."
          );
          break;
        }
        console.warn(formatted.warnings[i]);
      }
    }
  }
  printWarnings();
  if (isHotUpdate) {
    tryApplyUpdates();
  }
}
function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true;
  const formatted = formatStatsMessages({
    errors,
    warnings: []
  });
  if (typeof console !== "undefined" && typeof console.error === "function") {
    for (const error of formatted.errors) {
      console.error(error);
    }
  }
}
function handleAvailableHash(hash) {
  mostRecentCompilationHash = hash;
}
function isUpdateAvailable() {
  return mostRecentCompilationHash !== __webpack_hash__;
}
function canApplyUpdates() {
  return import.meta.webpackHot.status() === "idle";
}
function tryApplyUpdates() {
  if (!isUpdateAvailable()) {
    return;
  }
  if (!import.meta.webpackHot) {
    window.location.reload();
    return;
  }
  if (!canApplyUpdates()) {
    return;
  }
  function handleApplyUpdates(err, updatedModules) {
    const wantsForcedReload = err || !updatedModules;
    if (wantsForcedReload) {
      window.location.reload();
      return;
    }
    if (isUpdateAvailable()) {
      tryApplyUpdates();
    }
  }
  import.meta.webpackHot.check(true).then(
    (updatedModules) => {
      handleApplyUpdates(null, updatedModules);
    },
    (err) => {
      handleApplyUpdates(err, null);
    }
  );
}
var MAX_RETRIES = 100;
var connection = null;
var retry_counter = 0;
function onOpen() {
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("[HMR] connected.");
  }
}
function onMessage(e) {
  const message = JSON.parse(e.data);
  switch (message.type) {
    case "hash":
      handleAvailableHash(message.data);
      break;
    case "still-ok":
    case "ok":
      handleSuccess();
      break;
    case "content-changed":
      window.location.reload();
      break;
    case "warnings":
      handleWarnings(message.data);
      break;
    case "errors":
      handleErrors(message.data);
      break;
    default:
  }
}
async function sleep(msec = 1e3) {
  return new Promise((resolve) => {
    setTimeout(resolve, msec);
  });
}
async function onClose() {
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("[HMR] disconnected. Attempting to reconnect.");
  }
  removeListeners();
  await sleep(1e3);
  retry_counter++;
  if (connection && (connection.readyState === connection.CONNECTING || connection.readyState === connection.OPEN)) {
    retry_counter = 0;
    return;
  }
  if (retry_counter > MAX_RETRIES) {
    if (typeof console !== "undefined" && typeof console.info === "function") {
      console.info(
        "[HMR] Unable to establish a connection after exceeding the maximum retry attempts."
      );
    }
    retry_counter = 0;
    return;
  }
  reconnect();
}
function connect() {
  connection = new WebSocket(socketUrl);
  connection.addEventListener("open", onOpen);
  connection.addEventListener("close", onClose);
  connection.addEventListener("message", onMessage);
}
function removeListeners() {
  if (connection) {
    connection.removeEventListener("open", onOpen);
    connection.removeEventListener("close", onClose);
    connection.removeEventListener("message", onMessage);
  }
}
function reconnect() {
  if (connection) {
    connection = null;
  }
  connect();
}
connect();
