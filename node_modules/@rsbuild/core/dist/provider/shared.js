"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var shared_exports = {};
__export(shared_exports, {
  BUILTIN_LOADER: () => BUILTIN_LOADER,
  applyDefaultPlugins: () => applyDefaultPlugins,
  formatStats: () => formatStats,
  getCompiledPath: () => getCompiledPath,
  isSatisfyRspackVersion: () => isSatisfyRspackVersion,
  rspackMinVersion: () => rspackMinVersion
});
module.exports = __toCommonJS(shared_exports);
var import_node_path = require("node:path");
var import_shared = require("@rsbuild/shared");
var import_shared2 = require("@rsbuild/shared");
var import_shared3 = require("@rsbuild/shared");
var import_formatStats = require("../client/formatStats");
const applyDefaultPlugins = (plugins) => (0, import_shared3.awaitableGetter)([
  Promise.resolve().then(() => __toESM(require("./plugins/transition"))).then((m) => m.pluginTransition()),
  plugins.basic(),
  plugins.entry(),
  // plugins.cache(),
  plugins.target(),
  Promise.resolve().then(() => __toESM(require("./plugins/output"))).then((m) => m.pluginOutput()),
  Promise.resolve().then(() => __toESM(require("./plugins/resolve"))).then((m) => m.pluginResolve()),
  plugins.fileSize(),
  // cleanOutput plugin should before the html plugin
  plugins.cleanOutput(),
  plugins.asset(),
  plugins.html(),
  plugins.wasm(),
  plugins.moment(),
  plugins.nodeAddons(),
  plugins.define(),
  Promise.resolve().then(() => __toESM(require("./plugins/css"))).then((m) => m.pluginCss()),
  Promise.resolve().then(() => __toESM(require("./plugins/less"))).then((m) => m.pluginLess()),
  Promise.resolve().then(() => __toESM(require("./plugins/sass"))).then((m) => m.pluginSass()),
  Promise.resolve().then(() => __toESM(require("./plugins/minimize"))).then((m) => m.pluginMinimize()),
  Promise.resolve().then(() => __toESM(require("./plugins/progress"))).then((m) => m.pluginProgress()),
  Promise.resolve().then(() => __toESM(require("./plugins/swc"))).then((m) => m.pluginSwc()),
  plugins.externals(),
  plugins.splitChunks(),
  plugins.startUrl(),
  plugins.inlineChunk(),
  plugins.bundleAnalyzer(),
  plugins.rsdoctor(),
  plugins.networkPerformance(),
  plugins.preloadOrPrefetch(),
  plugins.performance(),
  plugins.server(),
  plugins.moduleFederation(),
  Promise.resolve().then(() => __toESM(require("./plugins/rspackProfile"))).then((m) => m.pluginRspackProfile())
]);
const rspackMinVersion = "0.5.0";
const compareSemver = (version1, version2) => {
  const parts1 = version1.split(".").map(Number);
  const parts2 = version2.split(".").map(Number);
  const len = Math.max(parts1.length, parts2.length);
  for (let i = 0; i < len; i++) {
    const item1 = parts1[i] ?? 0;
    const item2 = parts2[i] ?? 0;
    if (item1 > item2) {
      return 1;
    }
    if (item1 < item2) {
      return -1;
    }
  }
  return 0;
};
const isSatisfyRspackVersion = async (originalVersion) => {
  let version = originalVersion;
  if (version.includes("-canary")) {
    version = version.split("-canary")[0];
  }
  if (version && /^[\d\.]+$/.test(version)) {
    return compareSemver(version, rspackMinVersion) >= 0;
  }
  return true;
};
const getCompiledPath = (packageName) => {
  const providerCompilerPath = (0, import_node_path.join)(__dirname, "../../compiled", packageName);
  if (import_shared2.fse.existsSync(providerCompilerPath)) {
    return providerCompilerPath;
  }
  return (0, import_shared.getSharedPkgCompiledPath)(packageName);
};
const BUILTIN_LOADER = "builtin:";
const addNodePolyfillTip = (message) => {
  if (!message.includes(`Can't resolve`)) {
    return message;
  }
  const matchArray = message.match(/Can't resolve '(\w+)'/);
  if (!matchArray) {
    return message;
  }
  const moduleName = matchArray[1];
  const nodeModules = [
    "assert",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "https",
    "module",
    "net",
    "os",
    "path",
    "punycode",
    "process",
    "querystring",
    "readline",
    "repl",
    "stream",
    "_stream_duplex",
    "_stream_passthrough",
    "_stream_readable",
    "_stream_transform",
    "_stream_writable",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "vm",
    "zlib"
  ];
  if (moduleName && nodeModules.includes(moduleName)) {
    const tips = [
      `Tip: "${moduleName}" is a built-in Node.js module and cannot be imported in client-side code.`,
      `Check if you need to import Node.js module. If needed, you can use "@rsbuild/plugin-node-polyfill".`
    ];
    return `${message}

${import_shared.color.yellow(tips.join("\n"))}`;
  }
  return message;
};
function formatErrorMessage(errors) {
  const messages = errors.map((error) => addNodePolyfillTip(error));
  const text = `${messages.join("\n\n")}
`;
  const isTerserError = text.includes("from Terser");
  const title = import_shared.color.bold(
    import_shared.color.red(isTerserError ? "Minify error: " : "Compile error: ")
  );
  const tip = import_shared.color.yellow(
    isTerserError ? "Failed to minify with terser, check for syntax errors." : "Failed to compile, check the errors for troubleshooting."
  );
  return `${title}
${tip}
${text}`;
}
function formatStats(stats) {
  const statsData = stats.toJson({
    preset: "errors-warnings"
  });
  const { errors, warnings } = (0, import_formatStats.formatStatsMessages)(statsData);
  if (errors.length) {
    return {
      message: formatErrorMessage(errors),
      level: "error"
    };
  }
  if (warnings.length) {
    const title = import_shared.color.bold(import_shared.color.yellow("Compile Warning: \n"));
    return {
      message: `${title}${`${warnings.join("\n\n")}
`}`,
      level: "warning"
    };
  }
  return {};
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BUILTIN_LOADER,
  applyDefaultPlugins,
  formatStats,
  getCompiledPath,
  isSatisfyRspackVersion,
  rspackMinVersion
});
