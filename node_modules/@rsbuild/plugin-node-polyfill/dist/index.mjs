import { createRequire } from 'module';
var require = createRequire(import.meta['url']);

var __defProp = Object.defineProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../node_modules/.pnpm/@modern-js+module-tools@2.48.0/node_modules/@modern-js/module-tools/shims/esm.js
import { fileURLToPath } from "url";
import path from "path";

// src/libs.ts
var libs_exports = {};
__export(libs_exports, {
  _stream_duplex: () => _stream_duplex,
  _stream_passthrough: () => _stream_passthrough,
  _stream_readable: () => _stream_readable,
  _stream_transform: () => _stream_transform,
  _stream_writable: () => _stream_writable,
  assert: () => assert,
  buffer: () => buffer,
  child_process: () => child_process,
  cluster: () => cluster,
  console: () => console,
  constants: () => constants,
  crypto: () => crypto,
  dgram: () => dgram,
  dns: () => dns,
  domain: () => domain,
  events: () => events,
  fs: () => fs,
  http: () => http,
  https: () => https,
  module: () => module,
  net: () => net,
  os: () => os,
  path: () => path2,
  process: () => process,
  punycode: () => punycode,
  querystring: () => querystring,
  readline: () => readline,
  repl: () => repl,
  stream: () => stream,
  string_decoder: () => string_decoder,
  sys: () => sys,
  timers: () => timers,
  tls: () => tls,
  tty: () => tty,
  url: () => url,
  util: () => util,
  vm: () => vm,
  zlib: () => zlib
});
var assert = __require.resolve("assert/");
var buffer = __require.resolve("buffer/");
var child_process = null;
var cluster = null;
var console = __require.resolve("console-browserify");
var constants = __require.resolve("constants-browserify");
var crypto = __require.resolve("crypto-browserify");
var dgram = null;
var dns = null;
var domain = __require.resolve("domain-browser");
var events = __require.resolve("events/");
var fs = null;
var http = __require.resolve("stream-http");
var https = __require.resolve("https-browserify");
var module = null;
var net = null;
var os = __require.resolve("os-browserify/browser.js");
var path2 = __require.resolve("path-browserify");
var punycode = __require.resolve("punycode/");
var process = __require.resolve("process/browser.js");
var querystring = __require.resolve("querystring-es3/");
var readline = null;
var repl = null;
var stream = __require.resolve("stream-browserify");
var _stream_duplex = __require.resolve(
  "readable-stream/lib/_stream_duplex.js"
);
var _stream_passthrough = __require.resolve(
  "readable-stream/lib/_stream_passthrough.js"
);
var _stream_readable = __require.resolve(
  "readable-stream/lib/_stream_readable.js"
);
var _stream_transform = __require.resolve(
  "readable-stream/lib/_stream_transform.js"
);
var _stream_writable = __require.resolve(
  "readable-stream/lib/_stream_writable.js"
);
var string_decoder = __require.resolve("string_decoder/");
var sys = __require.resolve("util/util.js");
var timers = __require.resolve("timers-browserify");
var tls = null;
var tty = __require.resolve("tty-browserify");
var url = __require.resolve("url/");
var util = __require.resolve("util/util.js");
var vm = __require.resolve("vm-browserify");
var zlib = __require.resolve("browserify-zlib");

// src/index.ts
var getResolveFallback = (nodeLibs) => Object.keys(nodeLibs).reduce(
  (previous, name) => {
    if (nodeLibs[name]) {
      previous[name] = nodeLibs[name];
    } else {
      previous[name] = false;
    }
    return previous;
  },
  {}
);
var getProvideGlobals = async (globals) => {
  const result = {};
  if (globals?.Buffer !== false) {
    result.Buffer = [buffer, "Buffer"];
  }
  if (globals?.process !== false) {
    result.process = [process];
  }
  return result;
};
function pluginNodePolyfill(options = {}) {
  return {
    name: "rsbuild:node-polyfill",
    setup(api) {
      api.modifyBundlerChain(async (chain, { CHAIN_ID, isServer, bundler }) => {
        if (isServer) {
          return;
        }
        chain.resolve.fallback.merge(getResolveFallback(libs_exports));
        const provideGlobals = await getProvideGlobals(options.globals);
        if (Object.keys(provideGlobals).length) {
          chain.plugin(CHAIN_ID.PLUGIN.NODE_POLYFILL_PROVIDE).use(bundler.ProvidePlugin, [provideGlobals]);
        }
      });
    }
  };
}
export {
  pluginNodePolyfill
};
